"use strict";(globalThis.webpackChunkedge_ai=globalThis.webpackChunkedge_ai||[]).push([[924],{5219:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"face_authentication/retrieval","title":"Exercise 05: Vector Retrieval and Similarity Search","description":"Overview","source":"@site/docs/face_authentication/5_retrieval.md","sourceDirName":"face_authentication","slug":"/face_authentication/retrieval","permalink":"/docs/face_authentication/retrieval","draft":false,"unlisted":false,"editUrl":"https://github.com/Wyliodrn/edge-ai-101/tree/main/docs/face_authentication/5_retrieval.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Exercise 04: Local File Storage for Face Embeddings","permalink":"/docs/face_authentication/local_storage"},"next":{"title":"Exercise 06: Complete Face Authentication System","permalink":"/docs/face_authentication/full_application"}}');var r=n(4848),t=n(8453);const l={},a="Exercise 05: Vector Retrieval and Similarity Search",o={},c=[{value:"Overview",id:"overview",level:2},{value:"What is Vector Similarity Search?",id:"what-is-vector-similarity-search",level:2},{value:"Your Task",id:"your-task",level:2},{value:"Algorithm Steps:",id:"algorithm-steps",level:3},{value:"Implementation Approach:",id:"implementation-approach",level:3},{value:"Key Operations Needed:",id:"key-operations-needed",level:3},{value:"Key Implementation Details",id:"key-implementation-details",level:2},{value:"Edge Cases to Handle:",id:"edge-cases-to-handle",level:3},{value:"Performance Characteristics:",id:"performance-characteristics",level:3},{value:"Sorting Considerations:",id:"sorting-considerations",level:3},{value:"Testing",id:"testing",level:2},{value:"Example Usage",id:"example-usage",level:2},{value:"Production Vector Databases",id:"production-vector-databases",level:2},{value:"Why Specialized Vector DBs?",id:"why-specialized-vector-dbs",level:3},{value:"Recommended Options:",id:"recommended-options",level:3},{value:"Qdrant (Rust-Native) \u2b50",id:"qdrant-rust-native-",level:4},{value:"pgvector (PostgreSQL Extension)",id:"pgvector-postgresql-extension",level:4},{value:"Pinecone",id:"pinecone",level:4},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"exercise-05-vector-retrieval-and-similarity-search",children:"Exercise 05: Vector Retrieval and Similarity Search"})}),"\n",(0,r.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(i.p,{children:["This exercise teaches you how to implement vector similarity search - the core functionality that enables face recognition systems to find matching faces. You'll build a ",(0,r.jsx)(i.code,{children:"top_k"})," function that searches through stored embeddings to find the most similar faces to a query."]}),"\n",(0,r.jsx)(i.h2,{id:"what-is-vector-similarity-search",children:"What is Vector Similarity Search?"}),"\n",(0,r.jsx)(i.p,{children:"Vector similarity search is the process of:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Taking a query vector"})," (e.g., embedding of a face to identify)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Comparing it against a database"})," of stored vectors (known face embeddings)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Ranking results by similarity"})," (most similar faces first)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Returning the top matches"})," (k most similar faces)"]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"This is exactly how face authentication works:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Registration"}),": Store face embeddings in the database"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Login"}),": Capture new face, find most similar stored embedding"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Decision"}),": If similarity > threshold, grant access"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"your-task",children:"Your Task"}),"\n",(0,r.jsxs)(i.p,{children:["Implement the ",(0,r.jsx)(i.code,{children:"top_k"})," function that performs similarity search:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-rust",children:"pub fn top_k(storage: &dyn EmbeddingStorage, query: &[f32], k: usize) -> Result<Vec<(EmbeddingRecord, f32)>>\n"})}),"\n",(0,r.jsx)(i.h3,{id:"algorithm-steps",children:"Algorithm Steps:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Retrieve All Embeddings"}),": Get all stored embeddings from storage"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Calculate Similarities"}),": Compute cosine similarity between query and each stored embedding"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Sort by Similarity"}),": Order results from highest to lowest similarity"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Return Top-K"}),": Take only the k most similar results"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"implementation-approach",children:"Implementation Approach:"}),"\n",(0,r.jsx)(i.p,{children:"The algorithm follows these conceptual steps:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Retrieve All Embeddings"}),": Get stored embeddings from storage"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Calculate Similarities"}),": Compute similarity between query and each stored embedding"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Sort Results"}),": Order by similarity (highest first)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Return Top-K"}),": Take only the k most similar results"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"key-operations-needed",children:"Key Operations Needed:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Storage retrieval operations"}),"\n",(0,r.jsx)(i.li,{children:"Vector similarity computation (cosine similarity)"}),"\n",(0,r.jsx)(i.li,{children:"Sorting and ranking algorithms"}),"\n",(0,r.jsx)(i.li,{children:"Result limiting and formatting"}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Hint"}),": You'll need a vector-based cosine similarity function. Check the CHEATSHEET.md for similarity computation building blocks."]}),"\n",(0,r.jsx)(i.h2,{id:"key-implementation-details",children:"Key Implementation Details"}),"\n",(0,r.jsx)(i.h3,{id:"edge-cases-to-handle",children:"Edge Cases to Handle:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Empty Storage"}),": Return empty vector if no embeddings stored"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"k = 0"}),": Return empty vector"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"k > stored count"}),": Return all available embeddings"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Division by Zero"}),": Handle zero-magnitude vectors gracefully"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"performance-characteristics",children:"Performance Characteristics:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Time Complexity"}),": O(n \xd7 d + n log n) where n = number of stored embeddings, d = embedding dimension"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Space Complexity"}),": O(n) for storing similarity scores"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Scalability"}),": Linear scan works for thousands of embeddings, but not millions"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"sorting-considerations",children:"Sorting Considerations:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Use ",(0,r.jsx)(i.strong,{children:"descending order"})," (highest similarity first)"]}),"\n",(0,r.jsxs)(i.li,{children:["Handle ",(0,r.jsx)(i.strong,{children:"NaN values"})," with ",(0,r.jsx)(i.code,{children:"partial_cmp()"})," and ",(0,r.jsx)(i.code,{children:"unwrap_or()"})]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Stable sort"})," ensures consistent ordering for equal similarities"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"testing",children:"Testing"}),"\n",(0,r.jsx)(i.p,{children:"The tests verify that your implementation:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Returns Best Match First"}),": Most similar embedding appears first in results"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Sorts Correctly"}),": Results are in descending similarity order"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Respects K Limit"}),": Returns exactly k results (or fewer if less data available)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Handles Empty Storage"}),": Works correctly with no stored embeddings"]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Run tests with:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"cargo test\n"})}),"\n",(0,r.jsx)(i.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-rust",children:'// Create storage and add some face embeddings\nlet (mut storage, _path) = open_temp_storage()?;\nadd_record(storage.as_mut(), "Alice", vec![1.0, 0.0, 0.0])?;\nadd_record(storage.as_mut(), "Bob", vec![0.0, 1.0, 0.0])?;\nadd_record(storage.as_mut(), "Charlie", vec![0.8, 0.2, 0.0])?;\n\n// Search for faces similar to query\nlet query = vec![0.9, 0.1, 0.0];  // Similar to Alice and Charlie\nlet results = top_k(storage.as_ref(), &query, 2)?;\n\n// Results will be:\n// 1. Alice (similarity \u2248 0.95)\n// 2. Charlie (similarity \u2248 0.85)\n'})}),"\n",(0,r.jsx)(i.h2,{id:"production-vector-databases",children:"Production Vector Databases"}),"\n",(0,r.jsx)(i.p,{children:"While this exercise teaches the fundamentals, production systems use specialized vector databases for better performance:"}),"\n",(0,r.jsx)(i.h3,{id:"why-specialized-vector-dbs",children:"Why Specialized Vector DBs?"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Approximate Nearest Neighbor (ANN)"}),": Sub-linear search time using indexing"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Horizontal Scaling"}),": Handle millions/billions of vectors"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Real-time Updates"}),": Add/remove vectors without rebuilding indices"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Advanced Filtering"}),": Combine similarity search with metadata filters"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Optimized Storage"}),": Compressed vectors and efficient memory usage"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"recommended-options",children:"Recommended Options:"}),"\n",(0,r.jsx)(i.h4,{id:"qdrant-rust-native-",children:"Qdrant (Rust-Native) \u2b50"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Homepage"}),": ",(0,r.jsx)(i.a,{href:"https://qdrant.tech/",children:"https://qdrant.tech/"})]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Why Choose"}),": Written in Rust, excellent Rust client, HNSW indexing"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Use Case"}),": Perfect for Rust applications requiring high performance"]}),"\n"]}),"\n",(0,r.jsx)(i.h4,{id:"pgvector-postgresql-extension",children:"pgvector (PostgreSQL Extension)"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Homepage"}),": ",(0,r.jsx)(i.a,{href:"https://github.com/pgvector/pgvector",children:"https://github.com/pgvector/pgvector"})]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Why Choose"}),": SQL-based, ACID transactions, familiar ecosystem"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Use Case"}),": When you already use PostgreSQL and want vector search"]}),"\n"]}),"\n",(0,r.jsx)(i.h4,{id:"pinecone",children:"Pinecone"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Homepage"}),": ",(0,r.jsx)(i.a,{href:"https://www.pinecone.io/",children:"https://www.pinecone.io/"})]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Why Choose"}),": Fully managed, serverless, auto-scaling"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Use Case"}),": When you want zero infrastructure management"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,r.jsx)(i.p,{children:"Vector similarity search powers:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Face Recognition"}),": Find matching faces in databases"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Recommendation Systems"}),": Find similar products/content"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Semantic Search"}),": Find documents by meaning, not keywords"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Duplicate Detection"}),": Identify similar images/documents"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Anomaly Detection"}),": Find outliers in high-dimensional data"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(i.p,{children:"For production systems:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Indexing"}),": Use HNSW, IVF, or LSH for faster search"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Quantization"}),": Reduce vector precision to save memory"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Caching"}),": Cache frequently accessed embeddings"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Batching"}),": Process multiple queries together"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Filtering"}),": Pre-filter by metadata before similarity search"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(i.p,{children:"After completing this exercise, you'll understand:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"How face recognition systems find matching faces"}),"\n",(0,r.jsx)(i.li,{children:"The trade-offs between accuracy and performance in vector search"}),"\n",(0,r.jsx)(i.li,{children:"Why production systems need specialized vector databases"}),"\n",(0,r.jsx)(i.li,{children:"How to implement and optimize similarity search algorithms"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"This completes the face authentication workshop! You now have all the building blocks to create a complete face recognition system."})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>a});var s=n(6540);const r={},t=s.createContext(r);function l(e){const i=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);