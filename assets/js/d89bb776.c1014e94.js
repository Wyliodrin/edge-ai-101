"use strict";(globalThis.webpackChunkedge_ai=globalThis.webpackChunkedge_ai||[]).push([[428],{6784:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"face_authentication/similarity","title":"Exercise 03: Cosine Similarity for Face Authentication","description":"Overview","source":"@site/docs/face_authentication/3_similarity.md","sourceDirName":"face_authentication","slug":"/face_authentication/similarity","permalink":"/docs/face_authentication/similarity","draft":false,"unlisted":false,"editUrl":"https://github.com/Wyliodrn/edge-ai-101/tree/main/docs/face_authentication/3_similarity.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Exercise 02. ConvNeXt Model and Embedding Generation","permalink":"/docs/face_authentication/embeddings"},"next":{"title":"Exercise 04: Local File Storage for Face Embeddings","permalink":"/docs/face_authentication/local_storage"}}');var r=n(4848),l=n(8453);const t={},a="Exercise 03: Cosine Similarity for Face Authentication",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Why Cosine Similarity for Face Recognition?",id:"why-cosine-similarity-for-face-recognition",level:2},{value:"Mathematical Foundation",id:"mathematical-foundation",level:2},{value:"L2 Normalization",id:"l2-normalization",level:3},{value:"Cosine Similarity",id:"cosine-similarity",level:3},{value:"Your Tasks",id:"your-tasks",level:2},{value:"Task 1: Implement <code>normalize_l2()</code>",id:"task-1-implement-normalize_l2",level:3},{value:"Implementation Approach:",id:"implementation-approach",level:4},{value:"Task 2: Implement <code>cosine_similarity()</code>",id:"task-2-implement-cosine_similarity",level:3},{value:"Implementation Approach:",id:"implementation-approach-1",level:4},{value:"Technical Details",id:"technical-details",level:2},{value:"Tensor Shapes:",id:"tensor-shapes",level:3},{value:"Key Candle Operations:",id:"key-candle-operations",level:3},{value:"Testing",id:"testing",level:2},{value:"Understanding the Results",id:"understanding-the-results",level:2},{value:"Typical Similarity Ranges:",id:"typical-similarity-ranges",level:3},{value:"Authentication Thresholds:",id:"authentication-thresholds",level:3},{value:"Real-World Considerations",id:"real-world-considerations",level:2},{value:"Factors Affecting Similarity:",id:"factors-affecting-similarity",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"References",id:"references",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"exercise-03-cosine-similarity-for-face-authentication",children:"Exercise 03: Cosine Similarity for Face Authentication"})}),"\n",(0,r.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(i.p,{children:"This exercise teaches you how to compute cosine similarity between face embeddings - the core mathematical operation that enables face recognition. You'll implement L2 normalization and cosine similarity functions that determine whether two faces belong to the same person."}),"\n",(0,r.jsx)(i.h2,{id:"why-cosine-similarity-for-face-recognition",children:"Why Cosine Similarity for Face Recognition?"}),"\n",(0,r.jsx)(i.p,{children:"Cosine similarity is the gold standard for comparing face embeddings because it:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Measures Direction, Not Magnitude"}),': Focuses on the "shape" of the embedding vector, not its size']}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Handles Lighting Variations"}),": Less sensitive to brightness changes that might scale embedding values"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Provides Intuitive Scores"}),": Returns values between -1 and 1, where 1 means identical faces"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Industry Standard"}),": Used by most production face recognition systems"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"mathematical-foundation",children:"Mathematical Foundation"}),"\n",(0,r.jsx)(i.h3,{id:"l2-normalization",children:"L2 Normalization"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Formula"}),": ",(0,r.jsx)(i.code,{children:"normalized_vector = vector / ||vector||\u2082"})]}),"\n",(0,r.jsx)(i.p,{children:"L2 normalization ensures all embeddings have unit length (magnitude = 1), which:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Standardizes Comparisons"}),": All vectors have the same magnitude"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Improves Robustness"}),": Reduces sensitivity to lighting and scale variations"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Enables Fair Comparison"}),": Focuses on directional relationships"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Optimizes Similarity"}),": Makes cosine similarity equivalent to dot product"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"cosine-similarity",children:"Cosine Similarity"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Formula"}),": ",(0,r.jsx)(i.code,{children:"cosine_similarity = (A \xb7 B) / (||A|| \xd7 ||B||)"})]}),"\n",(0,r.jsxs)(i.p,{children:["For normalized vectors, this simplifies to just the dot product: ",(0,r.jsx)(i.code,{children:"A \xb7 B"})]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Key Properties"}),":"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Range"}),": [-1, 1] where 1 = identical, 0 = orthogonal, -1 = opposite"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Magnitude Invariant"}),": Only considers the angle between vectors"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Symmetric"}),": similarity(A, B) = similarity(B, A)"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"your-tasks",children:"Your Tasks"}),"\n",(0,r.jsxs)(i.h3,{id:"task-1-implement-normalize_l2",children:["Task 1: Implement ",(0,r.jsx)(i.code,{children:"normalize_l2()"})]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-rust",children:"fn normalize_l2(v: &Tensor) -> Result<Tensor>\n"})}),"\n",(0,r.jsx)(i.p,{children:"This helper function should:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Calculate L2 Norm"}),": Compute the magnitude of the vector"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Normalize"}),": Divide the vector by its norm to get unit length"]}),"\n"]}),"\n",(0,r.jsx)(i.h4,{id:"implementation-approach",children:"Implementation Approach:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Use tensor operations to compute the L2 norm (square, sum, square root)"}),"\n",(0,r.jsx)(i.li,{children:"Apply broadcasting division to normalize the vector"}),"\n",(0,r.jsx)(i.li,{children:"Ensure dimensions are handled correctly for broadcasting"}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Hint"}),": Check the CHEATSHEET.md for L2 normalization building blocks."]}),"\n",(0,r.jsxs)(i.h3,{id:"task-2-implement-cosine_similarity",children:["Task 2: Implement ",(0,r.jsx)(i.code,{children:"cosine_similarity()"})]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-rust",children:"pub fn cosine_similarity(emb_a: &Tensor, emb_b: &Tensor) -> Result<f32>\n"})}),"\n",(0,r.jsx)(i.p,{children:"This function should:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Normalize Both Embeddings"}),": Apply L2 normalization to both inputs"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Compute Dot Product"}),": Calculate the similarity using matrix operations"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Extract Scalar"}),": Convert the result tensor to a single f32 value"]}),"\n"]}),"\n",(0,r.jsx)(i.h4,{id:"implementation-approach-1",children:"Implementation Approach:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Use your ",(0,r.jsx)(i.code,{children:"normalize_l2"})," function on both input embeddings"]}),"\n",(0,r.jsx)(i.li,{children:"Perform matrix multiplication to compute the dot product"}),"\n",(0,r.jsx)(i.li,{children:"Handle tensor dimensions and extract the final scalar value"}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Hint"}),": Check the CHEATSHEET.md for cosine similarity building blocks and tensor operations."]}),"\n",(0,r.jsx)(i.h2,{id:"technical-details",children:"Technical Details"}),"\n",(0,r.jsx)(i.h3,{id:"tensor-shapes",children:"Tensor Shapes:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Input Embeddings"}),": ",(0,r.jsx)(i.code,{children:"[1, 768]"})," (batch size 1, 768 dimensions)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"After Normalization"}),": ",(0,r.jsx)(i.code,{children:"[1, 768]"})," (same shape, unit length)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"After Matrix Multiply"}),": ",(0,r.jsx)(i.code,{children:"[1, 1]"})," (scalar in tensor form)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Final Output"}),": ",(0,r.jsx)(i.code,{children:"f32"})," scalar value"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"key-candle-operations",children:"Key Candle Operations:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:".sqr()"})," - Element-wise square"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:".sum_keepdim(1)"})," - Sum along dimension 1, keep the dimension"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:".sqrt()"})," - Element-wise square root"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:".broadcast_div()"})," - Element-wise division with broadcasting"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:".matmul()"})," - Matrix multiplication"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:".transpose(0, 1)"})," - Swap dimensions 0 and 1"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:".squeeze()"})," - Remove dimensions of size 1"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:".to_vec0::<f32>()"})," - Convert 0D tensor to scalar"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"testing",children:"Testing"}),"\n",(0,r.jsx)(i.p,{children:"The test verifies that:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Same person (brad1.png vs brad2.png) has higher similarity than different people"}),"\n",(0,r.jsx)(i.li,{children:"The similarity computation works with real face embeddings"}),"\n",(0,r.jsx)(i.li,{children:"Values are in the expected range"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Run the test with:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"cargo test\n"})}),"\n",(0,r.jsx)(i.h2,{id:"understanding-the-results",children:"Understanding the Results"}),"\n",(0,r.jsx)(i.h3,{id:"typical-similarity-ranges",children:"Typical Similarity Ranges:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Same Person"}),": 0.7 - 0.95 (high similarity)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Different People"}),": 0.2 - 0.6 (lower similarity)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Identical Images"}),": ~1.0 (perfect similarity)"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"authentication-thresholds",children:"Authentication Thresholds:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"High Security"}),": 0.85+ (few false positives, some false negatives)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Balanced"}),": 0.75+ (good balance of security and usability)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"High Accessibility"}),": 0.65+ (fewer false negatives, more false positives)"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"real-world-considerations",children:"Real-World Considerations"}),"\n",(0,r.jsx)(i.h3,{id:"factors-affecting-similarity",children:"Factors Affecting Similarity:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Lighting Conditions"}),": Dramatic lighting can reduce similarity"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Facial Expressions"}),": Extreme expressions may lower scores"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Image Quality"}),": Blurry or low-resolution images affect accuracy"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Pose Variations"}),": Profile vs frontal views impact similarity"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(i.p,{children:"After completing this exercise, you'll be ready to:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Build storage systems for face embeddings (Exercise 04)"}),"\n",(0,r.jsx)(i.li,{children:"Implement similarity search and retrieval (Exercise 05)"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Cosine Similarity"}),": ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Cosine_similarity",children:"Wikipedia - Cosine Similarity"})]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Face Recognition Survey"}),": ",(0,r.jsx)(i.a,{href:"https://arxiv.org/abs/1804.06655",children:"Deep Face Recognition: A Survey"})]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"L2 Normalization"}),": ",(0,r.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Unit_vector",children:"Unit Vector Normalization"})]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>a});var s=n(6540);const r={},l=s.createContext(r);function t(e){const i=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(l.Provider,{value:i},e.children)}}}]);