"use strict";(globalThis.webpackChunkedge_ai=globalThis.webpackChunkedge_ai||[]).push([[992],{2032:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"face_authentication/local_storage","title":"Exercise 04: Local File Storage for Face Embeddings","description":"Overview","source":"@site/docs/face_authentication/4_local_storage.md","sourceDirName":"face_authentication","slug":"/face_authentication/local_storage","permalink":"/docs/face_authentication/local_storage","draft":false,"unlisted":false,"editUrl":"https://github.com/Wyliodrin/edge-ai-101/edit/main/docs/face_authentication/4_local_storage.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Exercise 03: Cosine Similarity for Face Authentication","permalink":"/docs/face_authentication/similarity"},"next":{"title":"Exercise 05: Vector Retrieval and Similarity Search","permalink":"/docs/face_authentication/retrieval"}}');var r=i(4848),t=i(8453);const l={},a="Exercise 04: Local File Storage for Face Embeddings",d={},c=[{value:"Overview",id:"overview",level:2},{value:"Why Storage Matters",id:"why-storage-matters",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Your Tasks",id:"your-tasks",level:2},{value:"Task 1: Implement <code>LocalFileStorage::new()</code>",id:"task-1-implement-localfilestoragenew",level:3},{value:"Implementation Approach:",id:"implementation-approach",level:4},{value:"Task 2: Implement <code>load_data()</code>",id:"task-2-implement-load_data",level:3},{value:"Implementation Approach:",id:"implementation-approach-1",level:4},{value:"Task 3: Implement <code>save_data()</code>",id:"task-3-implement-save_data",level:3},{value:"Implementation Approach:",id:"implementation-approach-2",level:4},{value:"Task 4: Implement <code>EmbeddingStorage</code> Trait",id:"task-4-implement-embeddingstorage-trait",level:3},{value:"<code>store_embedding()</code>",id:"store_embedding",level:4},{value:"<code>get_embedding()</code>",id:"get_embedding",level:4},{value:"<code>get_all_embeddings()</code>",id:"get_all_embeddings",level:4},{value:"<code>delete_embedding()</code>",id:"delete_embedding",level:4},{value:"Task 5: Implement <code>open_temp_storage()</code>",id:"task-5-implement-open_temp_storage",level:3},{value:"Implementation Approach:",id:"implementation-approach-3",level:4},{value:"Technical Details",id:"technical-details",level:2},{value:"JSON File Format:",id:"json-file-format",level:3},{value:"Concurrency Handling:",id:"concurrency-handling",level:3},{value:"Error Handling:",id:"error-handling",level:3},{value:"Testing",id:"testing",level:2},{value:"File Management",id:"file-management",level:2},{value:"Production Considerations",id:"production-considerations",level:2},{value:"Next Steps",id:"next-steps",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"exercise-04-local-file-storage-for-face-embeddings",children:"Exercise 04: Local File Storage for Face Embeddings"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"This exercise teaches you how to build a persistent storage system for face embeddings using local JSON files. You'll implement a complete storage solution that can save, retrieve, and manage embedding records - essential for any face authentication system that needs to remember users between sessions."}),"\n",(0,r.jsx)(n.h2,{id:"why-storage-matters",children:"Why Storage Matters"}),"\n",(0,r.jsx)(n.p,{children:"Face authentication systems need persistent storage to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Remember Users"}),": Store embeddings from registration for future login attempts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enable Comparison"}),": Retrieve stored embeddings to compare against live captures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Manage Identities"}),": Track multiple embeddings per user for better accuracy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Persist Data"}),": Maintain user data across application restarts"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,r.jsx)(n.p,{children:"The storage system uses a trait-based design for flexibility:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Data structure for each stored embedding\npub struct EmbeddingRecord {\n    pub id: String,                                    // Unique identifier\n    pub name: String,                                  // User name\n    pub embedding: Vec<f32>,                          // Face embedding vector\n    pub created_at: chrono::DateTime<chrono::Utc>,    // Timestamp\n    pub metadata: HashMap<String, String>,            // Additional data\n}\n\n// Storage interface (trait)\npub trait EmbeddingStorage {\n    fn store_embedding(&mut self, record: EmbeddingRecord) -> Result<()>;\n    fn get_embedding(&self, id: &str) -> Result<Option<EmbeddingRecord>>;\n    fn get_all_embeddings(&self) -> Result<Vec<EmbeddingRecord>>;\n    fn delete_embedding(&mut self, id: &str) -> Result<bool>;\n}\n\n// Local file implementation\npub struct LocalFileStorage {\n    file_path: String,\n    data: Mutex<HashMap<String, EmbeddingRecord>>,\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"your-tasks",children:"Your Tasks"}),"\n",(0,r.jsxs)(n.h3,{id:"task-1-implement-localfilestoragenew",children:["Task 1: Implement ",(0,r.jsx)(n.code,{children:"LocalFileStorage::new()"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub fn new(file_path: String) -> Result<Self>\n"})}),"\n",(0,r.jsx)(n.p,{children:"This constructor should:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Create Storage Instance"}),": Initialize the struct with the file path"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Set Up In-Memory Cache"}),": Create a Mutex-protected HashMap for fast access"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Load Existing Data"}),": Call ",(0,r.jsx)(n.code,{children:"load_data()"})," to read any existing records"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-approach",children:"Implementation Approach:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Initialize the struct fields with appropriate values"}),"\n",(0,r.jsx)(n.li,{children:"Set up thread-safe data structures for concurrent access"}),"\n",(0,r.jsx)(n.li,{children:"Load any existing data from the file system"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hint"}),": Check the CHEATSHEET.md for HashMap and Mutex patterns."]}),"\n",(0,r.jsxs)(n.h3,{id:"task-2-implement-load_data",children:["Task 2: Implement ",(0,r.jsx)(n.code,{children:"load_data()"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn load_data(&self) -> Result<()>\n"})}),"\n",(0,r.jsx)(n.p,{children:"This method should:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check File Existence"}),": Return early if file doesn't exist"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle Empty Files"}),": Deal gracefully with zero-byte files"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parse JSON"}),": Deserialize the file content into a HashMap"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Update Cache"}),": Store the loaded data in the in-memory HashMap"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-approach-1",children:"Implementation Approach:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use file system operations to check existence and size"}),"\n",(0,r.jsx)(n.li,{children:"Handle JSON deserialization with proper error handling"}),"\n",(0,r.jsx)(n.li,{children:"Update the in-memory cache with loaded data"}),"\n",(0,r.jsx)(n.li,{children:"Use proper mutex locking for thread safety"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hint"}),": Check the CHEATSHEET.md for JSON deserialization patterns."]}),"\n",(0,r.jsxs)(n.h3,{id:"task-3-implement-save_data",children:["Task 3: Implement ",(0,r.jsx)(n.code,{children:"save_data()"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn save_data(&self) -> Result<()>\n"})}),"\n",(0,r.jsx)(n.p,{children:"This method should:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Create Directory"}),": Ensure the parent directory exists"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Open File"}),": Create or truncate the target file"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Serialize Data"}),": Convert the HashMap to JSON format"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Write File"}),": Save the JSON to disk"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-approach-2",children:"Implementation Approach:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Handle directory creation for the file path"}),"\n",(0,r.jsx)(n.li,{children:"Use appropriate file opening options for writing"}),"\n",(0,r.jsx)(n.li,{children:"Serialize the in-memory data to JSON format"}),"\n",(0,r.jsx)(n.li,{children:"Ensure thread-safe access to the data"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hint"}),": Check the CHEATSHEET.md for JSON serialization and file operations."]}),"\n",(0,r.jsxs)(n.h3,{id:"task-4-implement-embeddingstorage-trait",children:["Task 4: Implement ",(0,r.jsx)(n.code,{children:"EmbeddingStorage"})," Trait"]}),"\n",(0,r.jsx)(n.h4,{id:"store_embedding",children:(0,r.jsx)(n.code,{children:"store_embedding()"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn store_embedding(&mut self, record: EmbeddingRecord) -> Result<()>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Add the record to in-memory storage and persist to disk"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"get_embedding",children:(0,r.jsx)(n.code,{children:"get_embedding()"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn get_embedding(&self, id: &str) -> Result<Option<EmbeddingRecord>>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Search for and return a record by its ID"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"get_all_embeddings",children:(0,r.jsx)(n.code,{children:"get_all_embeddings()"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn get_all_embeddings(&self) -> Result<Vec<EmbeddingRecord>>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Return all stored embedding records"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"delete_embedding",children:(0,r.jsx)(n.code,{children:"delete_embedding()"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn delete_embedding(&mut self, id: &str) -> Result<bool>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Remove a record by ID and return whether deletion was successful"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation Approach"}),": Use HashMap operations with proper mutex locking and persistence."]}),"\n",(0,r.jsxs)(n.h3,{id:"task-5-implement-open_temp_storage",children:["Task 5: Implement ",(0,r.jsx)(n.code,{children:"open_temp_storage()"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub fn open_temp_storage() -> Result<(Box<dyn EmbeddingStorage>, String)>\n"})}),"\n",(0,r.jsx)(n.p,{children:"This helper function should:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Generate Unique Path"}),": Create a temporary filename using UUID"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Create Storage"}),": Initialize a LocalFileStorage instance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Return Boxed Trait"}),": Return as a trait object for flexibility"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-approach-3",children:"Implementation Approach:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Generate a unique filename using UUID"}),"\n",(0,r.jsx)(n.li,{children:"Create a new storage instance with that path"}),"\n",(0,r.jsx)(n.li,{children:"Return both the storage and path for cleanup"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hint"}),": Use ",(0,r.jsx)(n.code,{children:"Uuid::new_v4()"})," for unique identifiers."]}),"\n",(0,r.jsx)(n.h2,{id:"technical-details",children:"Technical Details"}),"\n",(0,r.jsx)(n.h3,{id:"json-file-format",children:"JSON File Format:"}),"\n",(0,r.jsx)(n.p,{children:"The storage saves data as a JSON object where keys are record IDs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "uuid-1": {\n    "id": "uuid-1",\n    "name": "Alice",\n    "embedding": [0.1, 0.2, ...],\n    "created_at": "2024-01-01T12:00:00Z",\n    "metadata": {}\n  },\n  "uuid-2": { ... }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"concurrency-handling",children:"Concurrency Handling:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Uses ",(0,r.jsx)(n.code,{children:"Mutex<HashMap>"})," for thread-safe access to in-memory data"]}),"\n",(0,r.jsx)(n.li,{children:"Locks are held briefly during read/write operations"}),"\n",(0,r.jsx)(n.li,{children:"File I/O is synchronized through the mutex"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"error-handling",children:"Error Handling:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Gracefully handles missing files (starts with empty storage)"}),"\n",(0,r.jsx)(n.li,{children:"Deals with corrupted JSON (logs warning, starts fresh)"}),"\n",(0,r.jsxs)(n.li,{children:["Proper error propagation using ",(0,r.jsx)(n.code,{children:"Result<T>"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,r.jsx)(n.p,{children:"The provided tests verify:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Basic Storage"}),": Can store and retrieve records"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sorting"}),": Results are returned in correct order"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limits"}),": Respects k-parameter for top-k queries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Empty Storage"}),": Handles empty storage gracefully"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Run tests with:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cargo test\n"})}),"\n",(0,r.jsx)(n.h2,{id:"file-management",children:"File Management"}),"\n",(0,r.jsx)(n.p,{children:"The storage system:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Auto-creates"})," directories as needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handles"})," missing files gracefully"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Overwrites"})," files completely on each save (simple but safe)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Uses"})," pretty-printed JSON for human readability"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"production-considerations",children:"Production Considerations"}),"\n",(0,r.jsx)(n.p,{children:"This simple file-based approach works well for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Development and Testing"}),": Easy to inspect and debug"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Small Datasets"}),": Hundreds to thousands of embeddings"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single-User Applications"}),": No concurrent access needed"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For production systems, consider:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Database Storage"}),": PostgreSQL with pgvector extension"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Vector Databases"}),": Qdrant, Pinecone, Weaviate"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Concurrent Access"}),": Proper locking mechanisms"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backup Strategies"}),": Regular data backups"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"After completing this exercise, you'll be ready to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement similarity search and retrieval (Exercise 05)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This storage foundation is crucial for the face authentication system's ability to persist and retrieve user embeddings efficiently."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);